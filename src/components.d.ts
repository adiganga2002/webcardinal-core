/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { RoutingState, WebcAppLoaderType, WebcAppMenuMode } from "./interfaces";
export namespace Components {
    interface WebcAppContainer {
    }
    interface WebcAppErrorToast {
    }
    interface WebcAppIdentity {
        /**
          * Path or URL to an image.
         */
        "avatar"?: string | null;
        /**
          * Email of your brand or organization.
         */
        "email": string | null;
        /**
          * Name of your brand or organization.
         */
        "name": string | null;
    }
    interface WebcAppLoader {
        /**
          * Source path is prefixed with this path.
         */
        "basePath": string;
        /**
          * A webc-app-loader for a page or for a fallback page This information is required for translations
         */
        "isFallbackPage": boolean;
        /**
          * Fetch a HTML file and loads inside as normal children or in a wrapper.
         */
        "loader": WebcAppLoaderType;
        /**
          * If this property is set, WebCardinal.state.page will be saved for current page session.
         */
        "saveState": boolean;
        /**
          * If a skin is set for this page, this property will be set according to <code>webcardinal.json</code>.
         */
        "skin": string;
        /**
          * Source path for a HTML page.
         */
        "src": string;
        /**
          * Tag of the page set in <code>webcardinal.json</code>.
         */
        "tag": string;
    }
    interface WebcAppMenu {
        /**
          * There is the possibility to change the base path of your application, using <code>base</code> HTML Element: <psk-example>   <psk-code>    <base href="/my-custom-base">   </psk-code> </psk-example>  Both <code>webc-app-menu</code> and <code>webc-app-router</code> must share the same <code>basePath</code>.
         */
        "basePath": string;
        /**
          * Decides if <code>webc-app-identity</code> is rendered.<br> This property is set by Custom Variable <code>--disable-identity</code>.
         */
        "disableIdentity": boolean;
        /**
          * This Array is received from <code>ApplicationController</code>.
         */
        "items": any[];
        "mode": WebcAppMenuMode;
    }
    interface WebcAppMenuItem {
        "activate": () => Promise<void>;
        "basePath": string;
        "deactivate": () => Promise<void>;
        "item": { path: string; children: any; };
        "level": number;
        "menuElement": HTMLElement;
        "mode": string;
        "name": string;
        "url": string | null;
    }
    interface WebcAppRedirect {
        /**
          * Redirects to the specified URL.
         */
        "url": string;
    }
    interface WebcAppRoot {
        /**
          * It decides if the header is disabled or not.
         */
        "disableHeader": boolean;
        /**
          * It decides if the spinner of application should be automatically hidden
         */
        "disableLoaderHiding": boolean;
        /**
          * Component tag name for a UI loader.
         */
        "loader": string;
        /**
          * Path to a JavaScript file which is loaded before configuration from <code>webcardinal.json</code> is applied.<br>
         */
        "preload": string;
    }
    interface WebcAppRouter {
        /**
          * There is the possibility to change the base path of your application, using <code>base</code> HTML Element: <psk-example>   <psk-code>    <base href="/my-custom-base/sub-path/">   </psk-code> </psk-example>  Both <code>webc-app-router</code> and <code>webc-app-menu</code> must share the same <code>basePath</code>.
         */
        "basePath": string;
        /**
          * Similar to 404 page, if <code>window.location.href</code> does not match any page, this fallback will be shown. This page can be changed from <code>webcardinal.json</code>, using <code>pagesFallback</code>.
         */
        "fallbackPage": any;
        /**
          * This Array is received from <code>ApplicationController</code>.
         */
        "routes": any[];
    }
    interface WebcContainer {
        /**
          * This property is a string that will permit the developer to choose his own controller. If no value is set then the null default value will be taken and the component will use the basic Controller.
         */
        "controller": string;
        /**
          * If it is not specified, all the innerHTML will be placed inside the unnamed slot. Otherwise the content will replace the <code>webc-container</code> element form DOM.
         */
        "disableContainer": boolean;
        /**
          * The model from controller is exposed by this method.
         */
        "getModel": () => Promise<any>;
        /**
          * The translation model from controller is exposed by this method.
         */
        "getTranslationModel": () => Promise<any>;
    }
    interface WebcDatatable {
        "chain": string;
        "clearCurrentPage": () => Promise<void>;
        "curentPageIndex": number;
        "dataSize": number | undefined;
        "fillCurrentPage": (data: any) => Promise<void>;
        "hidePagination": boolean;
        "infiniteScrollPosition": string;
        "lastPageIndex": number;
        "loading": boolean;
        "pageSize": number;
        "pageSizeDelta": number;
        "useInfiniteScroll": boolean;
        "useOptimisticMode": boolean;
    }
    interface WebcDocs {
        /**
          * Component tag name (in lowercase) for which documentation is desired.
         */
        "for": string;
        /**
          * If this prop is set to <code>true</code> the source of fetched docs for current webc-docs component must be on your local workspace. Otherwise the source is <small><code>https://raw.githubusercontent.com</code></small>.
         */
        "local"?: boolean;
    }
    interface WebcLink {
        "href": string | null;
        /**
          * A unique identifier for each page, which was previously set in <code>webcardinal.json</code>
         */
        "tag": string | null;
    }
    interface WebcModal {
        /**
          * Sets if the modal will automatically show when the element is constructed.
         */
        "autoShow": boolean;
        /**
          * The text that will appear on the footer close button, if neither the "footer" slot nor modalFooterContent are provided.
         */
        "cancelButtonText": string;
        /**
          * Sets if the popup is centered on the screen or if it appear at the top of the screen.
         */
        "centered": boolean;
        /**
          * The text that will appear on the footer confirm button, if neither the "footer" slot nor modalFooterContent are provided.
         */
        "confirmButtonText": string;
        /**
          * This property is a string that will permit the developer to choose his own controller. If no value is set then the null default value will be taken and the component will use the basic Controller.
         */
        "controller": string;
        /**
          * Method that completely removes the modal from the DOM.
         */
        "destroy": () => Promise<void>;
        /**
          * Sets if the modal will automatically close when the user clicks outside of it.
         */
        "disableBackdropClosing": boolean;
        /**
          * Sets if the close button will be shown or not.
         */
        "disableCancelButton": boolean;
        /**
          * Sets if the modal can be closed
         */
        "disableClosing": boolean;
        /**
          * Decides if expand button should be displayed
         */
        "disableExpanding": boolean;
        /**
          * Sets if the modal has the footer displayed.
         */
        "disableFooter": boolean;
        /**
          * Sets if the modal expands to full screen.
         */
        "expanded": boolean;
        /**
          * Method that hides the modal.
         */
        "hide": () => Promise<void>;
        /**
          * The content that will be shown in the modal body, if template is not provided.
         */
        "modalContent": string;
        /**
          * The content that can be shown in the header, if provided and the "header" slot is missing from the content.
         */
        "modalDescription": string;
        /**
          * The content that can be shown in the footer, if provided and the "footer" slot is missing from the content.
         */
        "modalFooter": string;
        /**
          * The text that will be shown in the modal's header, if the "header" slot is not provided.
         */
        "modalTitle": string;
        "model": any;
        /**
          * Method that shows the modal.
         */
        "show": () => Promise<void>;
        /**
          * The name of the model that will be loaded. The generated path will have the format <code>${basePath + skinPath}/modals/${template}.html</code>.
         */
        "template": string;
        "translationModel": any;
    }
    interface WebcSkin {
        /**
          * Path to a stylesheet.
         */
        "href": string;
    }
    interface WebcSpinner {
    }
    interface WebcSsapp {
        "appName": string;
        "basicSetup": boolean;
        "landingPath": string;
        "params": { [indexer: string]: string };
        "seed": string;
    }
    interface WebcSsappSecure {
        "appName": string;
        "basicSetup": boolean;
        "landingPath": string;
        "params": { [indexer: string]: string };
        "seed": string;
    }
    interface WebcSwitch {
        "condition": string;
    }
    interface WebcTemplate {
        /**
          * If it is not specified, all the markup coming <code>template</code> attribute will be placed inside innerHTML after the unnamed slot. Otherwise the content will replace the <code>webc-template</code> element form DOM.
         */
        "disableContainer": boolean;
        /**
          * The model from controller is exposed by this method.
         */
        "getModel": () => Promise<any>;
        /**
          * The translation model from controller is exposed by this method.
         */
        "getTranslationModel": () => Promise<any>;
        /**
          * The name of the template that will be loaded. The generated path will have the format <code>${basePath + skinPath}/templates/${template}.html</code>.
         */
        "template": string;
    }
}
export interface WebcAppIdentityCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWebcAppIdentityElement;
}
export interface WebcAppLoaderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWebcAppLoaderElement;
}
export interface WebcAppMenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWebcAppMenuElement;
}
export interface WebcAppRootCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWebcAppRootElement;
}
export interface WebcAppRouterCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWebcAppRouterElement;
}
export interface WebcContainerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWebcContainerElement;
}
export interface WebcDatatableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWebcDatatableElement;
}
export interface WebcDocsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWebcDocsElement;
}
export interface WebcLinkCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWebcLinkElement;
}
export interface WebcModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWebcModalElement;
}
export interface WebcSsappCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWebcSsappElement;
}
export interface WebcSsappSecureCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWebcSsappSecureElement;
}
export interface WebcTemplateCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWebcTemplateElement;
}
declare global {
    interface HTMLWebcAppContainerElement extends Components.WebcAppContainer, HTMLStencilElement {
    }
    var HTMLWebcAppContainerElement: {
        prototype: HTMLWebcAppContainerElement;
        new (): HTMLWebcAppContainerElement;
    };
    interface HTMLWebcAppErrorToastElement extends Components.WebcAppErrorToast, HTMLStencilElement {
    }
    var HTMLWebcAppErrorToastElement: {
        prototype: HTMLWebcAppErrorToastElement;
        new (): HTMLWebcAppErrorToastElement;
    };
    interface HTMLWebcAppIdentityElement extends Components.WebcAppIdentity, HTMLStencilElement {
    }
    var HTMLWebcAppIdentityElement: {
        prototype: HTMLWebcAppIdentityElement;
        new (): HTMLWebcAppIdentityElement;
    };
    interface HTMLWebcAppLoaderElement extends Components.WebcAppLoader, HTMLStencilElement {
    }
    var HTMLWebcAppLoaderElement: {
        prototype: HTMLWebcAppLoaderElement;
        new (): HTMLWebcAppLoaderElement;
    };
    interface HTMLWebcAppMenuElement extends Components.WebcAppMenu, HTMLStencilElement {
    }
    var HTMLWebcAppMenuElement: {
        prototype: HTMLWebcAppMenuElement;
        new (): HTMLWebcAppMenuElement;
    };
    interface HTMLWebcAppMenuItemElement extends Components.WebcAppMenuItem, HTMLStencilElement {
    }
    var HTMLWebcAppMenuItemElement: {
        prototype: HTMLWebcAppMenuItemElement;
        new (): HTMLWebcAppMenuItemElement;
    };
    interface HTMLWebcAppRedirectElement extends Components.WebcAppRedirect, HTMLStencilElement {
    }
    var HTMLWebcAppRedirectElement: {
        prototype: HTMLWebcAppRedirectElement;
        new (): HTMLWebcAppRedirectElement;
    };
    interface HTMLWebcAppRootElement extends Components.WebcAppRoot, HTMLStencilElement {
    }
    var HTMLWebcAppRootElement: {
        prototype: HTMLWebcAppRootElement;
        new (): HTMLWebcAppRootElement;
    };
    interface HTMLWebcAppRouterElement extends Components.WebcAppRouter, HTMLStencilElement {
    }
    var HTMLWebcAppRouterElement: {
        prototype: HTMLWebcAppRouterElement;
        new (): HTMLWebcAppRouterElement;
    };
    interface HTMLWebcContainerElement extends Components.WebcContainer, HTMLStencilElement {
    }
    var HTMLWebcContainerElement: {
        prototype: HTMLWebcContainerElement;
        new (): HTMLWebcContainerElement;
    };
    interface HTMLWebcDatatableElement extends Components.WebcDatatable, HTMLStencilElement {
    }
    var HTMLWebcDatatableElement: {
        prototype: HTMLWebcDatatableElement;
        new (): HTMLWebcDatatableElement;
    };
    interface HTMLWebcDocsElement extends Components.WebcDocs, HTMLStencilElement {
    }
    var HTMLWebcDocsElement: {
        prototype: HTMLWebcDocsElement;
        new (): HTMLWebcDocsElement;
    };
    interface HTMLWebcLinkElement extends Components.WebcLink, HTMLStencilElement {
    }
    var HTMLWebcLinkElement: {
        prototype: HTMLWebcLinkElement;
        new (): HTMLWebcLinkElement;
    };
    interface HTMLWebcModalElement extends Components.WebcModal, HTMLStencilElement {
    }
    var HTMLWebcModalElement: {
        prototype: HTMLWebcModalElement;
        new (): HTMLWebcModalElement;
    };
    interface HTMLWebcSkinElement extends Components.WebcSkin, HTMLStencilElement {
    }
    var HTMLWebcSkinElement: {
        prototype: HTMLWebcSkinElement;
        new (): HTMLWebcSkinElement;
    };
    interface HTMLWebcSpinnerElement extends Components.WebcSpinner, HTMLStencilElement {
    }
    var HTMLWebcSpinnerElement: {
        prototype: HTMLWebcSpinnerElement;
        new (): HTMLWebcSpinnerElement;
    };
    interface HTMLWebcSsappElement extends Components.WebcSsapp, HTMLStencilElement {
    }
    var HTMLWebcSsappElement: {
        prototype: HTMLWebcSsappElement;
        new (): HTMLWebcSsappElement;
    };
    interface HTMLWebcSsappSecureElement extends Components.WebcSsappSecure, HTMLStencilElement {
    }
    var HTMLWebcSsappSecureElement: {
        prototype: HTMLWebcSsappSecureElement;
        new (): HTMLWebcSsappSecureElement;
    };
    interface HTMLWebcSwitchElement extends Components.WebcSwitch, HTMLStencilElement {
    }
    var HTMLWebcSwitchElement: {
        prototype: HTMLWebcSwitchElement;
        new (): HTMLWebcSwitchElement;
    };
    interface HTMLWebcTemplateElement extends Components.WebcTemplate, HTMLStencilElement {
    }
    var HTMLWebcTemplateElement: {
        prototype: HTMLWebcTemplateElement;
        new (): HTMLWebcTemplateElement;
    };
    interface HTMLElementTagNameMap {
        "webc-app-container": HTMLWebcAppContainerElement;
        "webc-app-error-toast": HTMLWebcAppErrorToastElement;
        "webc-app-identity": HTMLWebcAppIdentityElement;
        "webc-app-loader": HTMLWebcAppLoaderElement;
        "webc-app-menu": HTMLWebcAppMenuElement;
        "webc-app-menu-item": HTMLWebcAppMenuItemElement;
        "webc-app-redirect": HTMLWebcAppRedirectElement;
        "webc-app-root": HTMLWebcAppRootElement;
        "webc-app-router": HTMLWebcAppRouterElement;
        "webc-container": HTMLWebcContainerElement;
        "webc-datatable": HTMLWebcDatatableElement;
        "webc-docs": HTMLWebcDocsElement;
        "webc-link": HTMLWebcLinkElement;
        "webc-modal": HTMLWebcModalElement;
        "webc-skin": HTMLWebcSkinElement;
        "webc-spinner": HTMLWebcSpinnerElement;
        "webc-ssapp": HTMLWebcSsappElement;
        "webc-ssapp-secure": HTMLWebcSsappSecureElement;
        "webc-switch": HTMLWebcSwitchElement;
        "webc-template": HTMLWebcTemplateElement;
    }
}
declare namespace LocalJSX {
    interface WebcAppContainer {
    }
    interface WebcAppErrorToast {
    }
    interface WebcAppIdentity {
        /**
          * Path or URL to an image.
         */
        "avatar"?: string | null;
        /**
          * Email of your brand or organization.
         */
        "email"?: string | null;
        /**
          * Name of your brand or organization.
         */
        "name"?: string | null;
        /**
          * All properties enumerated before are automatically filled by webc-app-identity when this event is fired from <code>ApplicationController</code>.
         */
        "onWebcardinal:config:getIdentity"?: (event: WebcAppIdentityCustomEvent<any>) => void;
    }
    interface WebcAppLoader {
        /**
          * Source path is prefixed with this path.
         */
        "basePath"?: string;
        /**
          * A webc-app-loader for a page or for a fallback page This information is required for translations
         */
        "isFallbackPage"?: boolean;
        /**
          * Fetch a HTML file and loads inside as normal children or in a wrapper.
         */
        "loader"?: WebcAppLoaderType;
        /**
          * Routing configuration received from <code>webc-app-router</code>.
         */
        "onWebcardinal:routing:get"?: (event: WebcAppLoaderCustomEvent<RoutingState>) => void;
        /**
          * If this property is set, WebCardinal.state.page will be saved for current page session.
         */
        "saveState"?: boolean;
        /**
          * If a skin is set for this page, this property will be set according to <code>webcardinal.json</code>.
         */
        "skin"?: string;
        /**
          * Source path for a HTML page.
         */
        "src"?: string;
        /**
          * Tag of the page set in <code>webcardinal.json</code>.
         */
        "tag"?: string;
    }
    interface WebcAppMenu {
        /**
          * There is the possibility to change the base path of your application, using <code>base</code> HTML Element: <psk-example>   <psk-code>    <base href="/my-custom-base">   </psk-code> </psk-example>  Both <code>webc-app-menu</code> and <code>webc-app-router</code> must share the same <code>basePath</code>.
         */
        "basePath"?: string;
        /**
          * Decides if <code>webc-app-identity</code> is rendered.<br> This property is set by Custom Variable <code>--disable-identity</code>.
         */
        "disableIdentity"?: boolean;
        /**
          * This Array is received from <code>ApplicationController</code>.
         */
        "items"?: any[];
        "mode"?: WebcAppMenuMode;
        /**
          * Routing configuration received from <code>ApplicationController</code>.<br> This configuration includes different settings for pages, skins, modals, etc.;
         */
        "onWebcardinal:config:getRouting"?: (event: WebcAppMenuCustomEvent<any>) => void;
    }
    interface WebcAppMenuItem {
        "basePath"?: string;
        "item"?: { path: string; children: any; };
        "level"?: number;
        "menuElement"?: HTMLElement;
        "mode"?: string;
        "name"?: string;
        "url"?: string | null;
    }
    interface WebcAppRedirect {
        /**
          * Redirects to the specified URL.
         */
        "url"?: string;
    }
    interface WebcAppRoot {
        /**
          * It decides if the header is disabled or not.
         */
        "disableHeader"?: boolean;
        /**
          * It decides if the spinner of application should be automatically hidden
         */
        "disableLoaderHiding"?: boolean;
        /**
          * Component tag name for a UI loader.
         */
        "loader"?: string;
        /**
          * LogLevel configuration is received from <code>ApplicationController</code> when this event is fired.<br>
         */
        "onWebcardinal:config:getLogLevel"?: (event: WebcAppRootCustomEvent<any>) => void;
        /**
          * Path to a JavaScript file which is loaded before configuration from <code>webcardinal.json</code> is applied.<br>
         */
        "preload"?: string;
    }
    interface WebcAppRouter {
        /**
          * There is the possibility to change the base path of your application, using <code>base</code> HTML Element: <psk-example>   <psk-code>    <base href="/my-custom-base/sub-path/">   </psk-code> </psk-example>  Both <code>webc-app-router</code> and <code>webc-app-menu</code> must share the same <code>basePath</code>.
         */
        "basePath"?: string;
        /**
          * Similar to 404 page, if <code>window.location.href</code> does not match any page, this fallback will be shown. This page can be changed from <code>webcardinal.json</code>, using <code>pagesFallback</code>.
         */
        "fallbackPage"?: any;
        /**
          * Routing configuration received from <code>ApplicationController</code>.<br> This configuration includes different settings for pages, skins, modals, etc.;
         */
        "onWebcardinal:config:getRouting"?: (event: WebcAppRouterCustomEvent<any>) => void;
        /**
          * This Array is received from <code>ApplicationController</code>.
         */
        "routes"?: any[];
    }
    interface WebcContainer {
        /**
          * This property is a string that will permit the developer to choose his own controller. If no value is set then the null default value will be taken and the component will use the basic Controller.
         */
        "controller"?: string;
        /**
          * If it is not specified, all the innerHTML will be placed inside the unnamed slot. Otherwise the content will replace the <code>webc-container</code> element form DOM.
         */
        "disableContainer"?: boolean;
        /**
          * Through this event the model is received.
         */
        "onWebcardinal:model:get"?: (event: WebcContainerCustomEvent<any>) => void;
        "onWebcardinal:parentChain:get"?: (event: WebcContainerCustomEvent<any>) => void;
        /**
          * Through this event the translation model is received.
         */
        "onWebcardinal:translationModel:get"?: (event: WebcContainerCustomEvent<any>) => void;
    }
    interface WebcDatatable {
        "chain"?: string;
        "curentPageIndex"?: number;
        "dataSize"?: number | undefined;
        "hidePagination"?: boolean;
        "infiniteScrollPosition"?: string;
        "lastPageIndex"?: number;
        "loading"?: boolean;
        /**
          * Through this event the model is received.
         */
        "onWebcardinal:model:get"?: (event: WebcDatatableCustomEvent<any>) => void;
        /**
          * Through this event the translation model is received.
         */
        "onWebcardinal:translationModel:get"?: (event: WebcDatatableCustomEvent<any>) => void;
        "pageSize"?: number;
        "pageSizeDelta"?: number;
        "useInfiniteScroll"?: boolean;
        "useOptimisticMode"?: boolean;
    }
    interface WebcDocs {
        /**
          * Component tag name (in lowercase) for which documentation is desired.
         */
        "for"?: string;
        /**
          * If this prop is set to <code>true</code> the source of fetched docs for current webc-docs component must be on your local workspace. Otherwise the source is <small><code>https://raw.githubusercontent.com</code></small>.
         */
        "local"?: boolean;
        /**
          * Gets the docs source for current component.<br> In <code>webcardinal.json</code>, if there is a key named <code>docsSource</code> with value <code>'local'</code>, all webc-docs components will be configured for local docs.<br> Default value for <code>docsSource</code> is <code>'github'</code>.
         */
        "onWebcardinal:config:getDocsSource"?: (event: WebcDocsCustomEvent<any>) => void;
    }
    interface WebcLink {
        "href"?: string | null;
        /**
          * Through this event a mapping (tag-page) with all tags is received from <code>webc-app-router</code>.
         */
        "onWebcardinal:tags:get"?: (event: WebcLinkCustomEvent<any>) => void;
        /**
          * A unique identifier for each page, which was previously set in <code>webcardinal.json</code>
         */
        "tag"?: string | null;
    }
    interface WebcModal {
        /**
          * Sets if the modal will automatically show when the element is constructed.
         */
        "autoShow"?: boolean;
        /**
          * The text that will appear on the footer close button, if neither the "footer" slot nor modalFooterContent are provided.
         */
        "cancelButtonText"?: string;
        /**
          * Sets if the popup is centered on the screen or if it appear at the top of the screen.
         */
        "centered"?: boolean;
        /**
          * The text that will appear on the footer confirm button, if neither the "footer" slot nor modalFooterContent are provided.
         */
        "confirmButtonText"?: string;
        /**
          * This property is a string that will permit the developer to choose his own controller. If no value is set then the null default value will be taken and the component will use the basic Controller.
         */
        "controller"?: string;
        /**
          * Sets if the modal will automatically close when the user clicks outside of it.
         */
        "disableBackdropClosing"?: boolean;
        /**
          * Sets if the close button will be shown or not.
         */
        "disableCancelButton"?: boolean;
        /**
          * Sets if the modal can be closed
         */
        "disableClosing"?: boolean;
        /**
          * Decides if expand button should be displayed
         */
        "disableExpanding"?: boolean;
        /**
          * Sets if the modal has the footer displayed.
         */
        "disableFooter"?: boolean;
        /**
          * Sets if the modal expands to full screen.
         */
        "expanded"?: boolean;
        /**
          * The content that will be shown in the modal body, if template is not provided.
         */
        "modalContent"?: string;
        /**
          * The content that can be shown in the header, if provided and the "header" slot is missing from the content.
         */
        "modalDescription"?: string;
        /**
          * The content that can be shown in the footer, if provided and the "footer" slot is missing from the content.
         */
        "modalFooter"?: string;
        /**
          * The text that will be shown in the modal's header, if the "header" slot is not provided.
         */
        "modalTitle"?: string;
        "model"?: any;
        /**
          * Event that fires when the modal is pressed (only when the default footer is shown). The event will be passed with a boolean value to specify if the popup was closed due to a button press (true) or a click outside of the popup (false)
         */
        "onClosed"?: (event: WebcModalCustomEvent<boolean>) => void;
        /**
          * Event that fires when the confirm button is pressed (only when the default footer is shown).
         */
        "onConfirmed"?: (event: WebcModalCustomEvent<any>) => void;
        /**
          * Event that fires when the modal is initialised (after the modal content was successfully loaded).
         */
        "onInitialised"?: (event: WebcModalCustomEvent<HTMLElement>) => void;
        /**
          * The name of the model that will be loaded. The generated path will have the format <code>${basePath + skinPath}/modals/${template}.html</code>.
         */
        "template"?: string;
        "translationModel"?: any;
    }
    interface WebcSkin {
        /**
          * Path to a stylesheet.
         */
        "href"?: string;
    }
    interface WebcSpinner {
    }
    interface WebcSsapp {
        "appName"?: string;
        "basicSetup"?: boolean;
        "landingPath"?: string;
        "onWindowAction"?: (event: WebcSsappCustomEvent<any>) => void;
        "params"?: { [indexer: string]: string };
        "seed"?: string;
    }
    interface WebcSsappSecure {
        "appName"?: string;
        "basicSetup"?: boolean;
        "landingPath"?: string;
        "onWindowAction"?: (event: WebcSsappSecureCustomEvent<any>) => void;
        "params"?: { [indexer: string]: string };
        "seed"?: string;
    }
    interface WebcSwitch {
        "condition"?: string;
    }
    interface WebcTemplate {
        /**
          * If it is not specified, all the markup coming <code>template</code> attribute will be placed inside innerHTML after the unnamed slot. Otherwise the content will replace the <code>webc-template</code> element form DOM.
         */
        "disableContainer"?: boolean;
        /**
          * Through this event the model is received.
         */
        "onWebcardinal:model:get"?: (event: WebcTemplateCustomEvent<any>) => void;
        "onWebcardinal:parentChain:get"?: (event: WebcTemplateCustomEvent<any>) => void;
        /**
          * Through this event the translation model is received.
         */
        "onWebcardinal:translationModel:get"?: (event: WebcTemplateCustomEvent<any>) => void;
        /**
          * The name of the template that will be loaded. The generated path will have the format <code>${basePath + skinPath}/templates/${template}.html</code>.
         */
        "template"?: string;
    }
    interface IntrinsicElements {
        "webc-app-container": WebcAppContainer;
        "webc-app-error-toast": WebcAppErrorToast;
        "webc-app-identity": WebcAppIdentity;
        "webc-app-loader": WebcAppLoader;
        "webc-app-menu": WebcAppMenu;
        "webc-app-menu-item": WebcAppMenuItem;
        "webc-app-redirect": WebcAppRedirect;
        "webc-app-root": WebcAppRoot;
        "webc-app-router": WebcAppRouter;
        "webc-container": WebcContainer;
        "webc-datatable": WebcDatatable;
        "webc-docs": WebcDocs;
        "webc-link": WebcLink;
        "webc-modal": WebcModal;
        "webc-skin": WebcSkin;
        "webc-spinner": WebcSpinner;
        "webc-ssapp": WebcSsapp;
        "webc-ssapp-secure": WebcSsappSecure;
        "webc-switch": WebcSwitch;
        "webc-template": WebcTemplate;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "webc-app-container": LocalJSX.WebcAppContainer & JSXBase.HTMLAttributes<HTMLWebcAppContainerElement>;
            "webc-app-error-toast": LocalJSX.WebcAppErrorToast & JSXBase.HTMLAttributes<HTMLWebcAppErrorToastElement>;
            "webc-app-identity": LocalJSX.WebcAppIdentity & JSXBase.HTMLAttributes<HTMLWebcAppIdentityElement>;
            "webc-app-loader": LocalJSX.WebcAppLoader & JSXBase.HTMLAttributes<HTMLWebcAppLoaderElement>;
            "webc-app-menu": LocalJSX.WebcAppMenu & JSXBase.HTMLAttributes<HTMLWebcAppMenuElement>;
            "webc-app-menu-item": LocalJSX.WebcAppMenuItem & JSXBase.HTMLAttributes<HTMLWebcAppMenuItemElement>;
            "webc-app-redirect": LocalJSX.WebcAppRedirect & JSXBase.HTMLAttributes<HTMLWebcAppRedirectElement>;
            "webc-app-root": LocalJSX.WebcAppRoot & JSXBase.HTMLAttributes<HTMLWebcAppRootElement>;
            "webc-app-router": LocalJSX.WebcAppRouter & JSXBase.HTMLAttributes<HTMLWebcAppRouterElement>;
            "webc-container": LocalJSX.WebcContainer & JSXBase.HTMLAttributes<HTMLWebcContainerElement>;
            "webc-datatable": LocalJSX.WebcDatatable & JSXBase.HTMLAttributes<HTMLWebcDatatableElement>;
            "webc-docs": LocalJSX.WebcDocs & JSXBase.HTMLAttributes<HTMLWebcDocsElement>;
            "webc-link": LocalJSX.WebcLink & JSXBase.HTMLAttributes<HTMLWebcLinkElement>;
            "webc-modal": LocalJSX.WebcModal & JSXBase.HTMLAttributes<HTMLWebcModalElement>;
            "webc-skin": LocalJSX.WebcSkin & JSXBase.HTMLAttributes<HTMLWebcSkinElement>;
            "webc-spinner": LocalJSX.WebcSpinner & JSXBase.HTMLAttributes<HTMLWebcSpinnerElement>;
            "webc-ssapp": LocalJSX.WebcSsapp & JSXBase.HTMLAttributes<HTMLWebcSsappElement>;
            "webc-ssapp-secure": LocalJSX.WebcSsappSecure & JSXBase.HTMLAttributes<HTMLWebcSsappSecureElement>;
            "webc-switch": LocalJSX.WebcSwitch & JSXBase.HTMLAttributes<HTMLWebcSwitchElement>;
            "webc-template": LocalJSX.WebcTemplate & JSXBase.HTMLAttributes<HTMLWebcTemplateElement>;
        }
    }
}
